import numpy as np
import matplotlib.pyplot as plt
import math

#Euler step
def euler_step(f,x,t,dt):
    x_new = x+dt*f(x,t)
    t_new = t+dt
    return x_new,t_new

#RK4 step
def RK4_step(f, x, t, h):
    k1 = h * f(x, t)
    k2 = h * f(x + k1/2, t + h/2)
    k3 = h * f(x + k2/2, t + h/2)
    k4 = h * f(x + k3, t + h)
    x_new = x + (k1 + 2 * k2 + 2 * k3 + k4) / 6
    t_new = t + h
    return x_new, t_new

#Solve taking input as either 'Euler' or 'RK4'
def solve_to(f,x0,t0,t1,h,solver=''):
    t=t0
    x=x0
    while t < t1:
      dt = min(h, t1 - t)
      if solver == 'euler':
        x_new,t_new = euler_step(f,x,t,dt)
      elif solver == 'rk4':
        x_new,t_new = RK4_step(f, x, t, dt)
      x=x_new
      t=t_new
    return x, t

errorsEuler = []
errorsRK4 = []
def func(x, t): 
    return x
x0 = 1
t0 = 0
t1 = 1
h = 0.001
d=h

for i in range(1000):
    ans, t = solve_to(func, x0, t0, t1, d, 'euler')
    error = abs(math.e-ans)
    errorsEuler.append(error)
    d = d+h

d = 0.001
for i in range(1000):
    ans, t = solve_to(func, x0, t0, t1, d,'rk4')
    error = abs(math.e-ans)
    errorsRK4.append(error)
    d=d+h

tstep = np.linspace(h,d,1000)
plt.loglog(tstep, errorsEuler,'r', label = "Euler")
plt.loglog(tstep, errorsRK4, 'b', label = "RK4")
plt.xlabel('log(tstep)')
plt.ylabel('log(absolute error)')
plt.title('Size of Timestep Against Error Produced from the RK4 and Euler Methods')
plt.legend()
plt.show()